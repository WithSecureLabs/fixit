"""
interceptor.py

Part of the Fixit Project
WithSecure Labs (c) 2024

Description:
    This module defines the `MessageInterceptor` class, which is a threaded service designed
    to intercept FIX messages sent from the main Fixit client application. It enables the replacement
    of FIX messages generated by QuickFIX with raw message payloads defined by the user.
    This is required for Ad-Hoc scenarios where the QuickFIX library may override user-specific
    changes to the FIX messages, such as manipulaton of the BeginString or SenderCompID.

Key Features:
    - Intercepts and modifies outgoing FIX messages.
    - Handles multiple client connections with threading.
    - Supports user-defined message replacement via a peekable queue.

Usage:
    The `MessageInterceptor` class is initialized and started within the context of the
    Fixit application. It listens on a specified port, intercepts FIX messages, applies
    user-defined modifications, and forwards the modified messages to the FIX gateway.
"""

import signal
import socket
import select
import threading
from configparser import NoOptionError
from fixit.utils import PeekableQueue

#pylint: disable=too-many-instance-attributes
class MessageInterceptor():
    """
    Creates an interceptor for FIX messages leaving the main client application to run.

    Attributes:
        cli (object): The Fixit CLI instance.
        listen_host (str): The host address to listen on for incoming connections.
        listen_port (int): The port to listen on for incoming connections.
        remote_host (str): The target host to forward intercepted messages to.
        remote_port (int): The target port to forward intercepted messages to.
        _stop_event (threading.Event): Event used to signal thread termination.
        threads (list): List of active threads in the interceptor.
        timeout (int): Timeout value for socket operations.
    """

    def __init__(self, cli):
        """
        Initializes the MessageInterceptor with configuration values from the CLI.

        Args:
            cli (object): The Fixit CLI instance containing application configuration.
        """
        self.cli = cli
        self.listen_host = None
        self.listen_port = None
        self.remote_host = None
        self.remote_port = None
        self._stop_event = threading.Event()
        self.threads = []
        self.timeout = int(self.cli.orig_config.get("SESSION", "HeartBtInt"))

        signal.signal(signal.SIGINT, self.signal_handler)


    def start(self):
        """
        Starts the interceptor by creating and starting the main interception thread.

        This method retrieves configuration values, initializes the interception thread,
        and starts listening for incoming connections.
        """
        try:
            self.listen_host = self.cli.orig_config.get("SESSION", "FixitInterceptHost")
            self.listen_port = int(self.cli.orig_config.get("SESSION", "FixitInterceptPort"))
            self.remote_host = self.cli.orig_config.get("SESSION", "SocketConnectHost")
            self.remote_port = int(self.cli.orig_config.get("SESSION", "SocketConnectPort"))

            thread = threading.Thread(target=self.intercept_and_forward,
                                    args=(self.listen_host, self.listen_port,
                                    self.remote_host, self.remote_port),
                                    name="intercept_and_forward"
            )
            thread.start()
            self.threads.append(thread)

        except (KeyError, NoOptionError):
            pass


    def get_status(self):
        """
        Retrieves the current status of the interceptor.

        Returns:
            str: A string indicating whether the interceptor is running or stopped.
        """
        if  self.listen_port is None:
            return None

        status = "Stopped"
        if not self._stop_event.is_set():
            status = (
                f"\nInterceptor Started on TCP {self.listen_port} -> "
                f"{self.remote_host}:{self.remote_port}"
            )

        return status


    def intercept_and_forward(self, listen_host, listen_port, remote_host, remote_port):
        """
        Main loop for intercepting and forwarding intercepted messages.

        This method listens for incoming connections on a specified port, accepts
        client connections, and forwards intercepted messages to a remote host.

        Args:
            listen_host (str): Host address to listen on.
            listen_port (int): Port to listen on.
            remote_host (str): Target host to forward intercepted messages to.
            remote_port (int): Target port to forward intercepted messages to.
        """
        server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        server_socket.settimeout(self.timeout)
        server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

        try:
            server_socket.bind((listen_host, listen_port))
            server_socket.listen(5)
            server_socket.setblocking(False)

            while not self._stop_event.is_set():
                ready_to_read, _, _ = select.select([server_socket], [], [], 0.1)
                if self._stop_event.is_set():
                    break

                if server_socket in ready_to_read:
                    client_socket, _ = server_socket.accept()
                    thread = threading.Thread(target=self.handle_client,
                                            args=(client_socket, remote_host, remote_port),
                                            name="handle_client"
                    )
                    thread.start()
                    self.threads.append(thread)

        except OSError as e:
            self.cli.writer.error(
                f"Interceptor failed to bind to port {listen_host}:{listen_port}! {e}"
            )
        finally:
            server_socket.close()


    def handle_client(self, client_socket, remote_host, remote_port):
        """
        Handles client connections by forwarding messages to and from the remote host.

        Args:
            client_socket (socket): The socket object representing the client connection.
            remote_host (str): Target host to forward messages to.
            remote_port (int): Target port to forward messages to.
        """
        try:
            remote_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            remote_socket.settimeout(self.timeout)
            remote_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            remote_socket.connect((remote_host, remote_port))

            # Start threads to handle communication in both directions
            client_to_remote_thread = threading.Thread(target=self.forward_data,
                                    args=(client_socket, remote_socket),
                                    name="forward_data: client_socket -> remote_socket"
            )
            remote_to_client_thread = threading.Thread(target=self.forward_data,
                                    args=(remote_socket, client_socket),
                                    name="forward_data: remote_socket -> client_socket"
            )

            client_to_remote_thread.start()
            self.threads.append(client_to_remote_thread)

            remote_to_client_thread.start()
            self.threads.append(remote_to_client_thread)

            # Wait for both threads to finish
            client_to_remote_thread.join()
            remote_to_client_thread.join()

        except OSError as e:
            self.cli.writer.error(
                f"Interceptor failed to connect to {remote_host}:{remote_port}! {e}"
            )
        finally:
            client_socket.close()
            remote_socket.close()


    def forward_data(self, source_socket, destination_socket):
        """
        Forwards intercepted data from the source socket to the destination socket.

        Args:
            source_socket (socket): The socket to read data from.
            destination_socket (socket): The socket to forward data to.
        """
        try:
            while not self._stop_event.is_set():
                source_socket.setblocking(False)
                try:
                    data = source_socket.recv(4096)
                    if not data:
                        break

                    modified_data = self.modify_data(data)
                    destination_socket.sendall(modified_data)

                except (socket.timeout, BlockingIOError):
                    if self._stop_event.is_set():
                        break

        except OSError as e:
            #self.cli.writer.error(f"Interceptor forwarding error: {e}")
            pass

        finally:
            source_socket.close()
            destination_socket.close()


    def modify_data(self, data):
        """
        Modifies intercepted data by replacing it with user-specified data from the queue.

        Args:
            data (bytes): The original data to be modified.

        Returns:
            bytes: The modified data.
        """
        try:
            queue_data = self.cli.message_queue.get_nowait()
            data = queue_data

            self.cli.message_queue.task_done()
        except (PeekableQueue.Empty, KeyError) as e:
            pass

        return data


    #pylint: disable=unused-argument
    def signal_handler(self, sig, frame):
        """
        Handles keyboard interrupt signals to gracefully terminate the interceptor
        """
        self.cli.writer.print("")
        self.cli.commands["EXIT"].run(
            user_input=[""],
            cli=self.cli
        )


    def stop(self):
        """
        Terminates all active threads
        """
        self.cli.writer.info(f"Terminating Interceptor on TCP: {self.listen_port}")
        self._stop_event.set()
        for thread in self.threads:
            #self.cli.writer.info(f"Terminating thread: {thread.name}")
            thread.join(timeout=2.0)
